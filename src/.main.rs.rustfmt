
extern crate discord;
extern crate libc;

use discord::Discord;
use discord::model::Event;
use std::process::Command;
use libc::*;
use std::str;
use std::str::FromStr;
use std::process;
use std::mem;
use std::ptr;


fn main() {

  let mut value: i32 = mem::uninitialized();
  let addr = "0x1fc3de84"
  let local_iov = iovec {
    iov_base: &mut value as *mut _ as *mut c_void,
    iov_len: mem::size_of::<i32>(),
  };
  let remote_iov = iovec {
    iov_base: addr as *mut c_void,
    iov_len: mem::size_of::<i32>(),
  };
  //process_vm_readv(pid, &local_iov, 1, &remote_iov, 1, 0);

  let token = "MjQ3Mjk1MTM1MDQwMjc0NDMy.CwnHDQ.9_jgVEN-k2Zkxwdudiwdqbozpdw";
  // Log in to Discord using a bot token from the environment
  let discord = Discord::from_bot_token(token).expect("login failed");

  let output = Command::new("pgrep")
                          .arg("RocketLeague")
                          .output()
                          .expect("where's the PID?");


  let mut tmp_pid: String = String::from_utf8(output.stdout).unwrap();

  let tmp_pid_len = tmp_pid.len();

  tmp_pid.truncate(tmp_pid_len-1);

  println!("{}",tmp_pid);

  let pid: pid_t = tmp_pid.parse::<i32>().unwrap();

  println!("pr: {}",pid);


  // Establish and use a websocket connection
  /*let (mut connection, _) = discord.connect().expect("connect failed");
  println!("Ready.");
  loop {
    match connection.recv_event() {
      Ok(Event::MessageCreate(message)) => {
        println!("{} says: {}", message.author.name, message.content);
        if message.content == "!test" {
          let _ = discord.send_message(&message.channel_id, "This is a reply to the test.", "", false);
        } else if message.content == "!quit" {
          println!("Quitting.");
          break
        }
      }
      Ok(_) => {}
      Err(discord::Error::Closed(code, body)) => {
        println!("Gateway closed on us with code {:?}: {}", code, body);
        break
      }
      Err(err) => println!("Receive error: {:?}", err)
    }
  }*/
}
